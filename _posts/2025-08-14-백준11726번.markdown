---
layout: post
title: "백준 11726번"
date: 2025-08-14 
category: ps
---

# 백준 11726번 풀이

2 * 1 일 경우, 한가지 경우 존재
2 * 2 일 경우, 두가지 경우 존재
2 * 3 일 경우, 2 * 2 에서 한칸이 추가되는 경우 f(2) + f(1)
2 * 4 일 경우, 2 * 2 에서 두칸이 추가되는 경우  + 2 * 3 에서 한칸이 추가되는 경우 
따라서, 점화식은 2 * N 일 경우, f(N - 1) + f(N - 2)

## 첫번째 시도 

```cpp

#include <bits/stdc++.h>

using namespace std;

int getTileNum(int n){
	if(n == 1 ){
		return 1;
	}
	else if(n == 2) {
		return 2;
	}
	return getTileNum(n-1) + getTileNum(n-2);

}


```
처음에 이렇게 풀었으나 시간초과가 존재 
왜냐하면 시간복잡도는 O(2^N)
N=1억  1초정도 걸리는데 N이 1000까지만 안가더라도 대략적으로 제한시간인 1초를 초과
따라서, `메모제이션` 기법을 사용하여 해결해야한다. 



## 두번째 시도

빈 vector에 접근하려는건 항상 조심해야한다. 
그리고 배열 인덱스처럼 접근하려면 배열로 관리해서 저장 


출력결과
1000일 경우 -> 실행시간: 0.007 msec 1초 안에 수행된다는 걸 확인 

```cpp

void getTileNum(int n){
	
	v[0] = 0, v[1] = 1, v[2] = 2;

	for(int i = 3; i <= n; i++){
		v[i] = v[i - 1] + v[i - 2];
	}


}

```

## 세번째 시도 

시간 초과는 해결 했는데 int 범위에서 표현할 수 있는 수를 오버플로우로 넘어갈 경우 값이 제대로 안나온다. 그러므로 모듈러 연산을 처리해서 해결
모듈려 연산 법칙에 의해서
(a + b) % mod = (a % mod) + (b % mod) 가 같으므로 아래와 같이 처리 가능 

```cpp

void getTileNum(int n){
	
	v[0] = 0, v[1] = 1, v[2] = 2;

	for(int i = 3; i <= n; i++){
		v[i] = (v[i - 1] + v[i - 2]) % 10007;
	}


}

```